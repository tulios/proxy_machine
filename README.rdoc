= proxy_machine

== Description
  
A cool proxy implementation pattern in ruby

== Install

  sudo gem install proxy_machine
  
== Example usage

=== The awesome way:

  p = proxy_for [1, 2, 3]
  p.reverse => [3, 2, 1]
            
=== Defining callbefores and callafters in method level
                     
Callbefores:

  p = proxy_for [1, 2, 3], :before => {
    :reverse => lambda {|obj| puts 'before reverse'}
  }   
  
  p.reverse => before reverse
               [3, 2, 1]

Callafters:
               
  p = proxy_for [1, 2, 3], :after => {
   :reverse => lambda {|obj, result| result.sort}
  }   

  p.reverse => [1, 2, 3] # We reordered the list
               
=== Defining callbefores and callafters in all method calls

Callbefores:
This callback will receive a reference of the object, the symbol of the called method and the
arguments passed.

  p = proxy_for [1, 2, 3], :before_all => lambda {|obj, method, args| puts 'before all'}
  p.reverse => before all
               [3, 2, 1]
  
  p.size => before all
            3

Callafters:
This callback will receive a reference of the object, the result of execution (this result could be nil), 
the symbol of the called method and the arguments passed.
               
  p = proxy_for [1, 2, 3], :after_all => lambda {|obj, result, method, args| puts result}
  p.reverse => [1, 2, 3]
               [1, 2, 3] # puts
               
  p.size => 3
            3 # puts

=== Registering a class to perform the callafter or callbefore
                       
The constructor will receive the object, in case of a callback it will receive the result too.
You need to have a 'call' method. The ProxyMachine will create a new instance of the class
every time it need to use it. You could use this feature with the before_all and after_all too.

  # Example of class
  class SortPerformer
    def initialize object, result = nil, method = nil, args = nil
      @object = object; @result = result; @method = method, @args = args
    end
                             
    def call; @object.sort! end
  end
  
  p = proxy_for [1, 2, 3], :after => {
    :reverse => SortPerformer
  }
  
  p.reverse => [1, 2, 3]
  
=== How to detect that the object is a proxy?

The beautiful way:

  o1 = [1, 2, 3]
  o1.proxied? => false

  o2 = proxy_for [1, 2, 3] 
  o2.proxied? => true

Other way:

  p = proxy_for [1, 2, 3]
  defined? p.proxied_class?
                
=== Getting access to the original object
                                
Call original_object method in the proxy object.

  proxy = proxy_for [1, 2, 3]
  proxy.proxied? => true
  proxy.original_object.proxied? => false
  
=== Special options

1 - allow_dinamic: Allow execute methods based on method missing, that do not exists actually.
When allow_dinamic is enabled, proxy_machine will not check if this method really exists.
Default is false.

  # Example of class
  class MyClass
    attr_accessor :value
    def method_missing(symbol, *args); 'nice!'; end
  end
  
  p = proxy_for MyClass.new, :allow_dinamic => true, :before => {
    :magic_method => lambda {|obj| obj.value = 'other value' }
  }
  
  p.magic_method => 'other value'
  
2 - avoid_original_execution: When this option is enabled, proxy_machine will not call the original method.
Default is false.
  
  p = proxy_for [3, 2, 1], 
    :avoid_original_execution => true,
    :before => {
      :empty? => lambda {|obj| obj.sort!}
    }
    
  p.empty? => nil
  p.original_object => [1, 2, 3]
                      
=== Trying it in irb

  irb
  require 'proxy_machine'
  proxy_for...
  
=== Other ways:

1º - Creates a proxy for the informed object

  p = Proxy.new [1,2,3]
  p.size => 3

2º - A proxy with a before callback.

  p = Proxy.new [1,2,3], :before => {
    :size => lambda {|obj| puts "before: #{obj.inspect}"}
  }
  
  p.size => before: [1, 2, 3]
            3
                  
3º - A proxy with a after callback

  p = Proxy.new [1,2,3], :after => {
    :size => lambda {|obj, result| puts "after: #{obj.inspect}: result => #{result}"}
  }

  p.size => after: [1, 2, 3]: result => 3
            3
                 
4º - Both

  p = Proxy.new [1,2,3], 
                :before => {
                  :size => lambda {|obj| puts "before: #{obj.inspect}"}
                }, :after => {
                  :size => lambda {|obj, result| puts "after: #{obj.inspect}: result => #{result}"}
                }

== Copyright

Copyright (c) 2010 Túlio Ornelas. See LICENSE for details.                